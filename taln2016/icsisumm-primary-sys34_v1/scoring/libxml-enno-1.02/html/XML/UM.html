<HTML><HEAD><TITLE>XML::UM - Convert UTF-8 strings to any encoding supported by XML::Encoding</TITLE></HEAD><BODY><H1><A NAME="NAME">NAME

</A></H1><P>XML::UM - Convert UTF-8 strings to any encoding supported by XML::Encoding

<P><HR><H1><A NAME="SYNOPSIS">SYNOPSIS

</A></H1><PRE> use XML::UM;

</PRE><PRE> # Set directory with .xml files that comes with XML::Encoding distribution
 # Always include the trailing slash!
 $XML::UM::ENCDIR = '/home1/enno/perlModules/XML-Encoding-1.01/maps/';

</PRE><PRE> # Create the encoding routine
 my $encode = XML::UM::get_encode (
	Encoding =&gt; 'ISO-8859-2',
	EncodeUnmapped =&gt; \&amp;XML::UM::encode_unmapped_dec);

</PRE><PRE> # Convert a string from UTF-8 to the specified Encoding
 my $encoded_str = $encode-&gt;($utf8_str);

</PRE><PRE> # Remove circular references for garbage collection
 XML::UM::dispose_encoding ('ISO-8859-2');

</PRE><P><HR><H1><A NAME="DESCRIPTION">DESCRIPTION

</A></H1><P>This module provides methods to convert UTF-8 strings to any XML encoding
that <A>XML::Encoding</A> supports. It creates mapping routines from the .xml
files that can be found in the maps/ directory in the <A>XML::Encoding</A>
distribution. Note that the XML::Encoding distribution does install the 
.enc files in your perl directory, but not the.xml files they were created
from. That's why you have to specify $ENCDIR as in the SYNOPSIS.

<P>This implementation uses the XML::Encoding class to parse the .xml
file and creates a hash that maps UTF-8 characters (each consisting of up
to 4 bytes) to their equivalent byte sequence in the specified encoding. 
Note that large mappings may consume a lot of memory! 

<P>Future implementations may parse the .enc files directly, or
do the conversions entirely in XS (i.e. C code.)

<P><HR><H1><A NAME="get_encode_Encoding_STRING_EncodeUnmapped_SUB_">get_encode (Encoding =&gt; STRING, EncodeUnmapped =&gt; SUB)

</A></H1><P>The central entry point to this module is the XML::UM::get_encode() method. 
It forwards the call to the global $XML::UM::FACTORY, which is defined as
an instance of XML::UM::SlowMapperFactory by default. Override this variable
to plug in your own mapper factory.

<P>The XML::UM::SlowMapperFactory creates an instance of XML::UM::SlowMapper
(and caches it for subsequent use) that reads in the .xml encoding file and
creates a hash that maps UTF-8 characters to encoded characters.

<P>The get_encode() method of XML::UM::SlowMapper is called, finally, which
generates an anonimous subroutine that uses the hash to convert 
multi-character UTF-8 blocks to the proper encoding.

<P><HR><H1><A NAME="dispose_encoding_encoding_name_">dispose_encoding ($encoding_name)

</A></H1><P>Call this to free the memory used by the SlowMapper for a specific encoding.
Note that in order to free the big conversion hash, the user should no longer
have references to the subroutines generated by get_encode().

<P>The parameters to the get_encode() method (defined as name/value pairs) are:

<DL><DT><A NAME="_Encoding_"><STRONG><P>* Encoding

</STRONG></A><DD>The name of the desired encoding, e.g. 'ISO-8859-2'

<DT><A NAME="_EncodeUnmapped_Default_XML_UM_encode_unmapped_dec_"><STRONG><P>* EncodeUnmapped (Default: \&amp;XML::UM::encode_unmapped_dec)

</STRONG></A><DD>Defines how Unicode characters not found in the mapping file (of the 
specified encoding) are printed. 
By default, they are converted to decimal entity references, like '&amp;#123;'

<P>Use \&amp;XML::UM::encode_unmapped_hex for hexadecimal constants, like '&amp;#xAB;'

</DL><P><HR><H1><A NAME="CAVEATS">CAVEATS

</A></H1><P>I'm not exactly sure about which Unicode characters in the range (0 .. 127) 
should be mapped to themselves. See comments in XML/UM.pm near
%DEFAULT_ASCII_MAPPINGS.

<P>The encodings that expat supports by default are currently not supported, 
(e.g. UTF-16, ISO-8859-1),
because there are no .enc files available for these encodings.
This module needs some more work. If you have the time, please help!

<P><HR><H1><A NAME="AUTHOR">AUTHOR

</A></H1><P>Send bug reports, hints, tips, suggestions to Enno Derksen at
&lt;<I>enno@att.com</I>&gt;. 

<P><HR><I><FONT SIZE="-1">Last updated: Wed Feb 23 13:37:36 2000</FONT></I></BODY></HTML>
