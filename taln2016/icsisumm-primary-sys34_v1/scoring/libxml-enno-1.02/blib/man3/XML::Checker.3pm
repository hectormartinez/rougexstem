.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Checker 3"
.TH XML::Checker 3 "2000-01-31" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
XML::Checker \- A perl module for validating XML
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
XML::Checker::Parser \- an XML::Parser that validates at parse time
.PP
XML::DOM::ValParser \- an XML::DOM::Parser that validates at parse time
.PP
(Some of the package names may change! This is only an alpha release...)
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::Checker can be used in different ways to validate \s-1XML\s0. See the manual
pages of XML::Checker::Parser and XML::DOM::ValParser
for more information. 
.PP
This document only describes common topics like error handling
and the XML::Checker class itself.
.PP
\&\s-1WARNING:\s0 Not all errors are currently checked. Almost everything is subject to
change. Some reported errors may not be real errors.
.SH "ERROR HANDLING"
.IX Header "ERROR HANDLING"
Whenever XML::Checker (or one of the packages that uses XML::Checker) detects a
potential error, the 'fail handler' is called. It is currently also called 
to report information, like how many times an Entity was referenced. 
(The whole error handling mechanism is subject to change, I'm afraid...)
.PP
The default fail handler is \fIXML::Checker::print_error()\fR, which prints an error 
message to \s-1STDERR\s0. It does not stop the XML::Checker, so it will continue 
looking for other errors. 
The error message is created with \fIXML::Checker::error_string()\fR.
.PP
You can define your
own fail handler in two ways, locally and globally. Use a local variable to
temporarily override the fail handler. This way the default fail handler is restored
when the local variable goes out of scope, esp. when exceptions are thrown e.g.
.PP
.Vb 5
\& # Using a local variable to temporarily override the fail handler (preferred)
\& { # new block - start of local scope
\&   local $XML::Checker::FAIL = \e&my_fail;
\&   ... your code here ...
\& } # end of block - the previous fail handler is restored
.Ve
.PP
You can also set the error handler globally, risking that your code may not 
be reusable or may clash with other modules that use XML::Checker.
.PP
.Vb 3
\& # Globally setting the fail handler (not recommended)
\& $XML::Checker::FAIL = \e&my_fail;
\& ... rest of your code ...
.Ve
.PP
The fail handler is called with the following parameters ($code, \f(CW$msg\fR, \f(CW@context\fR), 
where \f(CW$code\fR is the error code, \f(CW$msg\fR is the error description and 
\&\f(CW@context\fR contains information on where the error occurred. The \f(CW@context\fR is
a (ordered) list of (key,value) pairs and can easily be turned into a hash.
It contains the following information:
.PP
.Vb 6
\& Element - tag name of Element node (if applicable)
\& Attr - attribute name (if applicable)
\& ChildElementIndex - if applicable (see error 157)
\& line - only when parsing
\& column - only when parsing
\& byte - only when parsing (-1 means: end of file)
.Ve
.PP
Some examples of fail handlers:
.PP
.Vb 7
\& # Don't print info messages
\& sub my_fail
\& {
\&     my $code = shift;
\&     print STDERR XML::Checker::error_message ($code, @_)
\&         if $code < 300;
\& }
.Ve
.PP
.Vb 7
\& # Die when the first error is encountered - this will stop
\& # the parsing process. Ignore information messages.
\& sub my_fail
\& {
\&     my $code = shift;
\&     die XML::Checker::error_message ($code, @_) if $code < 300;
\& }
.Ve
.PP
.Vb 8
\& # Count the number of undefined NOTATION references
\& # and print the error as usual
\& sub my_fail
\& {
\&     my $code = shift;
\&     $count_undef_notations++ if $code == 100;
\&     XML::Checker::print_error ($code, @_);
\& }
.Ve
.PP
.Vb 7
\& # Die when an error is encountered.
\& # Don't die if a warning or info message is encountered, just print a message.
\& sub my_fail {
\&     my $code = shift;
\&     die XML::Checker::error_string ($code, @_) if $code < 200;
\&     XML::Checker::print_error ($code, @_);
\& }
.Ve
.SH "INSIGNIFICANT WHITESPACE"
.IX Header "INSIGNIFICANT WHITESPACE"
XML::Checker keeps track of whether whitespace found in character data 
is significant or not. It is considered insignicant if it is found inside
an element that has a \s-1ELEMENT\s0 rule that is not of type Mixed or of type \s-1ANY\s0. 
(A Mixed \s-1ELEMENT\s0 rule does contains the #PCDATA keyword. 
An \s-1ANY\s0 rule contains the \s-1ANY\s0 keyword. See the \s-1XML\s0 spec for more info.)
.PP
XML::Checker can not determine whether whitespace is insignificant in those two 
cases, because they both allow regular character data to appear within
\&\s-1XML\s0 elements and XML::Checker can therefore not deduce whether whitespace 
is part of the actual data or was just added for readability of the \s-1XML\s0 file.
.PP
XML::Checker::Parser and XML::DOM::ValParser both have the option to skip
insignificant whitespace when setting \fBSkipInsignifWS\fR to 1 in their constructor.
If set, they will not call the Char handler when insignificant whitespace is
encountered. This means that in XML::DOM::ValParser no Text nodes are created
for insignificant whitespace.
.PP
Regardless of whether the SkipInsignifWS options is set, XML::Checker always 
keeps track of whether whitespace is insignificant. After making a call to
XML::Checker's Char handler, you can find out if it was insignificant whitespace
by calling the isInsignifWS method.
.PP
When using multiple (nested) XML::Checker instances or when using XML::Checker
without using XML::Checker::Parser or XML::DOM::ValParser (which hardly anybody
probably will), make sure to set a local variable in the scope of your checking
code, e.g.
.PP
.Vb 4
\&  { # new block - start of local scope
\&    local $XML::Checker::INSIGNIF_WS = 0;
\&    ... insert your code here ...
\&  } # end of scope
.Ve
.SH "ERROR CODES"
.IX Header "ERROR CODES"
There are 3 categories, errors, warnings and info messages.
(The codes are still subject to change, as well the error descriptions.) 
.PP
Most errors have a link to the appropriate Validaty Constraint (\fB\s-1VC\s0\fR)
or other section in the \s-1XML\s0 specification.
.Sh "\s-1ERROR\s0 Messages"
.IX Subsection "ERROR Messages"
.Sh "100 \- 109"
.IX Subsection "100 - 109"
.IP "\(bu" 4
\&\fB100\fR \- undefined \s-1NOTATION\s0 [$notation] in \s-1ATTLIST\s0
.Sp
The \s-1ATTLIST\s0 contained a Notation reference that was not defined in a
\&\s-1NOTATION\s0 definition. 
\&\fB\s-1VC:\s0\fR Notation Attributes
.IP "\(bu" 4
\&\fB101\fR \- undefined \s-1ELEMENT\s0 [$tagName]
.Sp
The specified Element was never defined in an \s-1ELEMENT\s0 definition.
This is not an error according to the \s-1XML\s0 spec.
See Element Type Declarations
.IP "\(bu" 4
\&\fB102\fR \- undefined unparsed \s-1ENTITY\s0 [$entity]
.Sp
The attribute value referenced an undefined unparsed entity.
\&\fB\s-1VC:\s0\fR Entity Name
.IP "\(bu" 4
\&\fB103\fR \- undefined attribute [$attrName]
.Sp
The specified attribute was not defined in an \s-1ATTLIST\s0 for that Element.
\&\fB\s-1VC:\s0\fR Attribute Value Type
.Sh "110 \- 119"
.IX Subsection "110 - 119"
.IP "\(bu" 4
\&\fB110\fR \- attribute [$attrName] of element [$tagName] already defined
.Sp
The specified attribute was already defined in this \s-1ATTLIST\s0 definition or
in a previous one.
This is not an error according to the \s-1XML\s0 spec.
See Attribute-List Declarations
.IP "\(bu" 4
\&\fB111\fR \- \s-1ID\s0 [$value] already defined
.Sp
An \s-1ID\s0 with the specified value was already defined in an attribute
within the same document.
\&\fB\s-1VC:\s0\fR \s-1ID\s0
.IP "\(bu" 4
\&\fB112\fR \- unparsed \s-1ENTITY\s0 [$entity] already defined
.Sp
This is not an error according to the \s-1XML\s0 spec.
See Entity Declarations
.IP "\(bu" 4
\&\fB113\fR \- \s-1NOTATION\s0 [$notation] already defined
.IP "\(bu" 4
\&\fB114\fR \- \s-1ENTITY\s0 [$entity] already defined
.Sp
This is not an error according to the \s-1XML\s0 spec.
See Entity Declarations
.IP "\(bu" 4
\&\fB115\fR \- \s-1ELEMENT\s0 [$name] already defined
\&\fB\s-1VC:\s0\fR Unique Element Type Declaration
.Sh "120 \- 129"
.IX Subsection "120 - 129"
.IP "\(bu" 4
\&\fB120\fR \- invalid default \s-1ENTITY\s0 [$default]
.Sp
(Or \s-1IDREF\s0 or \s-1NMTOKEN\s0 instead of \s-1ENTITY\s0.)
The \s-1ENTITY\s0, \s-1IDREF\s0 or \s-1NMTOKEN\s0 reference in the default attribute 
value for an attribute with types \s-1ENTITY\s0, \s-1IDREF\s0 or \s-1NMTOKEN\s0 was not
valid.
\&\fB\s-1VC:\s0\fR Attribute Default Legal
.IP "\(bu" 4
\&\fB121\fR \- invalid default [$token] in \s-1ENTITIES\s0 [$default]
.Sp
(Or \s-1IDREFS\s0 or \s-1NMTOKENS\s0 instead of \s-1ENTITIES\s0)
One of the \s-1ENTITY\s0, \s-1IDREF\s0 or \s-1NMTOKEN\s0 references in the default attribute 
value for an attribute with types \s-1ENTITIES\s0, \s-1IDREFS\s0 or \s-1NMTOKENS\s0 was not
valid.
\&\fB\s-1VC:\s0\fR Attribute Default Legal
.IP "\(bu" 4
\&\fB122\fR \- invalid default attribute value [$default]
.Sp
The specified default attribute value is not a valid attribute value.
\&\fB\s-1VC:\s0\fR Attribute Default Legal
.IP "\(bu" 4
\&\fB123\fR \- invalid default \s-1ID\s0 [$default], must be #REQUIRED or #IMPLIED
.Sp
The default attribute value for an attribute of type \s-1ID\s0 has to be 
#REQUIRED or #IMPLIED.
\&\fB\s-1VC:\s0\fR \s-1ID\s0 Attribute Default
.IP "\(bu" 4
\&\fB124\fR \- bad model [$model] for \s-1ELEMENT\s0 [$name]
.Sp
The model in the \s-1ELEMENT\s0 definition did not conform to the \s-1XML\s0 syntax 
for Mixed models.
See Mixed Content
.Sh "130 \- 139"
.IX Subsection "130 - 139"
.IP "\(bu" 4
\&\fB130\fR \- invalid \s-1NMTOKEN\s0 [$attrValue]
.Sp
The attribute value is not a valid NmToken token.
\&\fB\s-1VC:\s0\fR Enumeration
.IP "\(bu" 4
\&\fB131\fR \- invalid \s-1ID\s0 [$attrValue]
.Sp
The specified attribute value is not a valid Name token.
\&\fB\s-1VC:\s0\fR \s-1ID\s0
.IP "\(bu" 4
\&\fB132\fR \- invalid \s-1IDREF\s0 [$value]
.Sp
The specified attribute value is not a valid Name token.  
\&\fB\s-1VC:\s0\fR \s-1IDREF\s0
.IP "\(bu" 4
\&\fB133\fR \- invalid \s-1ENTITY\s0 name [$name]
.Sp
The specified attribute value is not a valid Name token.  
\&\fB\s-1VC:\s0\fR Entity Name
.IP "\(bu" 4
\&\fB134\fR \- invalid Enumeration value [$value] in \s-1ATTLIST\s0
.Sp
The specified value is not a valid NmToken (see \s-1XML\s0 spec for def.)
See definition of NmToken
.IP "\(bu" 4
\&\fB135\fR \- empty \s-1NOTATION\s0 list in \s-1ATTLIST\s0
.Sp
The \s-1NOTATION\s0 list of the \s-1ATTLIST\s0 definition did not contain any \s-1NOTATION\s0
references.
See definition of NotationType
.IP "\(bu" 4
\&\fB136\fR \- empty Enumeration list in \s-1ATTLIST\s0
.Sp
The \s-1ATTLIST\s0 definition of the attribute of type Enumeration did not
contain any values.
See definition of Enumeration
.IP "\(bu" 4
\&\fB137\fR \- invalid \s-1ATTLIST\s0 type [$type]
.Sp
The attribute type has to be one of: \s-1ID\s0, \s-1IDREF\s0, \s-1IDREFS\s0, \s-1ENTITY\s0, \s-1ENTITIES\s0, 
\&\s-1NMTOKEN\s0, \s-1NMTOKENS\s0, \s-1CDATA\s0, \s-1NOTATION\s0 or an Enumeration.
See definition of AttType
.Sh "150 \- 159"
.IX Subsection "150 - 159"
.IP "\(bu" 4
\&\fB150\fR \- bad #FIXED attribute value [$value], it should be [$default]
.Sp
The specified attribute was defined as #FIXED in the \s-1ATTLIST\s0 definition
and the found attribute \f(CW$value\fR differs from the specified \f(CW$default\fR value.
\&\fB\s-1VC:\s0\fR Fixed Attribute Default
.IP "\(bu" 4
\&\fB151\fR \- only one \s-1ID\s0 allowed in \s-1ATTLIST\s0 per element first=[$attrName]
.Sp
The \s-1ATTLIST\s0 definitions for an Element may contain only one attribute
with the type \s-1ID\s0. The specified \f(CW$attrName\fR is the one that was found first.
\&\fB\s-1VC:\s0\fR One \s-1ID\s0 per Element Type
.IP "\(bu" 4
\&\fB152\fR \- Element should be \s-1EMPTY\s0, found Element [$tagName]
.Sp
The \s-1ELEMENT\s0 definition for the specified Element said it should be
\&\s-1EMPTY\s0, but a child Element was found.
\&\fB\s-1VC:\s0\fR Element Valid (sub1)
.IP "\(bu" 4
\&\fB153\fR \- Element should be \s-1EMPTY\s0, found text [$text]
.Sp
The \s-1ELEMENT\s0 definition for the specified Element said it should be
\&\s-1EMPTY\s0, but text was found. Currently, whitespace is not allowed between the
open and close tag. (This may be wrong, please give feedback.)
To allow whitespace (subject to change), set:
.Sp
.Vb 1
\&    $XML::Checker::Context::EMPTY::ALLOW_WHITE_SPACE = 1;
.Ve
.Sp
\&\fB\s-1VC:\s0\fR Element Valid (sub1)
.IP "\(bu" 4
\&\fB154\fR \- bad order of Elements Found=[$found] RE=[$re]
.Sp
The child elements of the specified Element did not match the
regular expression found in the \s-1ELEMENT\s0 definition. \f(CW$found\fR contains
a comma separated list of all the child element tag names that were found.
\&\f(CW$re\fR contains the (decoded) regular expression that was used internally.
\&\fB\s-1VC:\s0\fR Element Valid
.IP "\(bu" 4
\&\fB155\fR \- more than one root Element [$tags]
.Sp
An \s-1XML\s0 Document may only contain one Element.
\&\f(CW$tags\fR is a comma separated list of element tag names encountered sofar.
XML::Parser (expat) throws 'no element found' exception.
See two_roots.xml for an example.
See definition of document
.IP "\(bu" 4
\&\fB156\fR \- unexpected root Element [$tagName], expected [$rootTagName]
.Sp
The tag name of the root Element of the \s-1XML\s0 Document differs from the name 
specified in the \s-1DOCTYPE\s0 section.
XML::Parser (expat) throws 'not well\-formed' exception.
See bad_root.xml for an example.
\&\fB\s-1VC:\s0\fR Root Element Type
.IP "\(bu" 4
\&\fB157\fR \- unexpected Element [$tagName]
.Sp
The \s-1ELEMENT\s0 definition for the specified Element does not allow child
Elements with the specified \f(CW$tagName\fR.
\&\fB\s-1VC:\s0\fR Element Valid
.Sp
The error context contains ChildElementIndex which is the index within 
its parent Element (counting only Element nodes.)
.IP "\(bu" 4
\&\fB158\fR \- unspecified value for #IMPLIED attribute [$attrName]
.Sp
The \s-1ATTLIST\s0 for the specified attribute said the attribute was #IMPLIED,
which means the user application should supply a value, but the attribute
value was not specified. (User applications should pass a value and set
\&\f(CW$specified\fR to 1 in the Attr handler.)
.IP "\(bu" 4
\&\fB159\fR \- unspecified value for #REQUIRED attribute [$attrName]
.Sp
The \s-1ATTLIST\s0 for the specified attribute said the attribute was #REQUIRED,
which means that a value should have been specified.
\&\fB\s-1VC:\s0\fR Required Attribute
.Sh "160 \- 169"
.IX Subsection "160 - 169"
.IP "\(bu" 4
\&\fB160\fR \- invalid Enumeration value [$attrValue]
.Sp
The specified attribute value does not match one of the Enumeration values
in the \s-1ATTLIST\s0.
\&\fB\s-1VC:\s0\fR Enumeration
.IP "\(bu" 4
\&\fB161\fR \- invalid \s-1NOTATION\s0 value [$attrValue]
.Sp
The specifed attribute value was not found in the list of possible \s-1NOTATION\s0 
references as found in the \s-1ATTLIST\s0 definition.
\&\fB\s-1VC:\s0\fR Notation Attributes
.IP "\(bu" 4
\&\fB162\fR \- undefined \s-1NOTATION\s0 [$attrValue]
.Sp
The \s-1NOTATION\s0 referenced by the specified attribute value was not defined.
\&\fB\s-1VC:\s0\fR Notation Attributes
.Sh "\s-1WARNING\s0 Messages (200 and up)"
.IX Subsection "WARNING Messages (200 and up)"
.IP "\(bu" 4
\&\fB200\fR \- undefined \s-1ID\s0 [$id] was referenced [$n] times
.Sp
The specified \s-1ID\s0 was referenced \f(CW$n\fR times, but never defined in an attribute
value with type \s-1ID\s0.
\&\fB\s-1VC:\s0\fR \s-1IDREF\s0
.Sh "\s-1INFO\s0 Messages (300 and up)"
.IX Subsection "INFO Messages (300 and up)"
.IP "\(bu" 4
\&\fB300\fR \- [$n] references to \s-1ID\s0 [$id]
.Sp
The specified \s-1ID\s0 was referenced \f(CW$n\fR times.
.Sh "Not checked"
.IX Subsection "Not checked"
The following errors are already checked by XML::Parser (expat) and
are currently not checked by XML::Checker:
.PP
(?? \s-1TODO\s0 \- add more info)
.IP "root element is missing" 4
.IX Item "root element is missing"
XML::Parser (expat) throws 'no element found' exception. 
See no_root.xml for an example.
.SH "XML::Checker"
.IX Header "XML::Checker"
XML::Checker can be easily plugged into your application. 
It uses mostly the same style of event handlers (or callbacks) as XML::Parser.
See XML::Parser manual page for descriptions of most handlers. 
.PP
It also implements PerlSAX style event handlers. See \*(L"PerlSAX interface\*(R".
.PP
Currently, the XML::Checker object is a blessed hash with the following 
(potentially useful) entries:
.PP
.Vb 6
\& $checker->{RootElement} - root element name as found in the DOCTYPE
\& $checker->{NOTATION}->{$notation} - is 1 if the NOTATION was defined
\& $checker->{ENTITY}->{$name} - contains the (first) ENTITY value if defined
\& $checker->{Unparsed}->{$entity} - is 1 if the unparsed ENTITY was defined
\& $checker->{ID}->{$id} - is 1 if the ID was defined
\& $checker->{IDREF}->{$id} - number of times the ID was referenced
.Ve
.PP
.Vb 5
\& # Less useful:
\& $checker->{ERule}->{$tag} - the ELEMENT rules by Element tag name
\& $checker->{ARule}->{$tag} - the ATTLIST rules by Element tag name
\& $checker->{Context} - context stack used internally
\& $checker->{CurrARule} - current ATTLIST rule for the current Element
.Ve
.Sh "XML:Checker methods"
.IX Subsection "XML:Checker methods"
This section is only interesting when using XML::Checker directly.
XML::Checker supports most event handlers that XML::Parser supports with minor 
differences. Note that the XML::Checker event handler methods are 
instance methods and not static, so don't forget to call them like this,
without passing \f(CW$expat\fR (as in the XML::Parser) handlers:
.PP
.Vb 1
\& $checker->Start($tagName);
.Ve
.IP "Constructor" 4
.IX Item "Constructor"
.Vb 2
\& $checker = new XML::Checker;
\& $checker = new XML::Checker (%user_args);
.Ve
.Sp
User data may be stored by client applications. Only \f(CW$checker\fR\->{User} is
guaranteed not to clash with internal hash keys.
.IP "getRootElement ()" 4
.IX Item "getRootElement ()"
.Vb 1
\& $tagName = $checker->getRootElement;
.Ve
.Sp
Returns the root element name as found in the \s-1DOCTYPE\s0
.Sh "Expat interface"
.IX Subsection "Expat interface"
XML::Checker supports what I call the \fIExpat\fR interface, which is 
the collection of methods you normally specify as the callback handlers
when using XML::Parser.
.PP
Only the following XML::Parser handlers are currently supported:
Init, Final, Char, Start, End, Element, Attlist, Doctype,
Unparsed, Entity, Notation. 
.PP
I don't know how to correctly support the Default handler for all XML::Parser
releases. The Start handler works a little different (see below) and I
added Attr, InitDomElem, FinalDomElem, \s-1CDATA\s0 and EntityRef handlers.
See XML::Parser for a description of the handlers that are not listed below.
.PP
Note that this interface may disappear, when the PerlSAX interface stabilizes.
.IP "Start ($tag)" 4
.IX Item "Start ($tag)"
.Vb 1
\& $checker->Start($tag);
.Ve
.Sp
Call this when an Element with the specified \f(CW$tag\fR name is encountered.
Different from the Start handler in XML::Parser, in that no attributes 
are passed in (use the Attr handler for those.)
.ie n .IP "Attr ($tag, $attrName\fR, \f(CW$attrValue\fR, \f(CW$isSpecified)" 4
.el .IP "Attr ($tag, \f(CW$attrName\fR, \f(CW$attrValue\fR, \f(CW$isSpecified\fR)" 4
.IX Item "Attr ($tag, $attrName, $attrValue, $isSpecified)"
.Vb 1
\& $checker->Attr($tag,$attrName,$attrValue,$spec);
.Ve
.Sp
Checks an attribute with the specified \f(CW$attrName\fR and \f(CW$attrValue\fR against the
\&\s-1ATTLIST\s0 definition of the element with the specified \f(CW$tag\fR name.
\&\f(CW$isSpecified\fR means whether the attribute was specified (1) or defaulted (0).
.IP "EndAttr ()" 4
.IX Item "EndAttr ()"
.Vb 1
\& $checker->EndAttr;
.Ve
.Sp
This should be called after all attributes are passed with \fIAttr()\fR.
It will check which of the #REQUIRED attributes were not specified and generate
the appropriate error (159) for each one that is missing.
.IP "\s-1CDATA\s0 ($text)" 4
.IX Item "CDATA ($text)"
.Vb 1
\& $checker->CDATA($text);
.Ve
.Sp
This should be called whenever CDATASections are encountered.
Similar to Char handler (but might perform different checks later...)
.ie n .IP "EntityRef ($entity, $isParameterEntity)" 4
.el .IP "EntityRef ($entity, \f(CW$isParameterEntity\fR)" 4
.IX Item "EntityRef ($entity, $isParameterEntity)"
.Vb 1
\& $checker->EntityRef($entity,$isParameterEntity);
.Ve
.Sp
Checks the \s-1ENTITY\s0 reference. Set \f(CW$isParameterEntity\fR to 1 for 
entity references that start with '%'.
.IP "InitDomElem () and FinalDomElem ()" 4
.IX Item "InitDomElem () and FinalDomElem ()"
Used by \fIXML::DOM::Element::check()\fR to initialize (and cleanup) the 
context stack when checking a single element.
.Sh "PerlSAX interface"
.IX Subsection "PerlSAX interface"
XML::Checker now also supports the PerlSAX interface, so you can use XML::Checker
wherever you use PerlSAX handlers.
.PP
XML::Checker implements the following methods: start_document, end_document,
start_element, end_element, characters, processing_instruction, comment,
start_cdata, end_cdata, entity_reference, notation_decl, unparsed_entity_decl,
entity_decl, element_decl, attlist_decl, doctype_decl, xml_decl
.PP
Not implemented: set_document_locator, ignorable_whitespace
.PP
See PerlSAX.pod for details. (It is called lib/PerlSAX.pod in the libxml-perl 
distribution which can be found at \s-1CPAN\s0.)
.SH "CAVEATS"
.IX Header "CAVEATS"
This is an alpha release. Almost everything is subject to change.
.SH "AUTHOR"
.IX Header "AUTHOR"
Send bug reports, hints, tips, suggestions to Enno Derksen at
<\fIenno@att.com\fR>. 
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The home page of XML::Checker at <http://www.erols.com/enno/checker/index.html>
.PP
The \s-1XML\s0 spec (Extensible Markup Language 1.0) at <http://www.w3.org/TR/REC\-xml>
.PP
The XML::Parser and XML::Parser::Expat manual pages.
.PP
The other packages that come with XML::Checker: 
XML::Checker::Parser, XML::DOM::ValParser
.PP
The \s-1DOM\s0 Level 1 specification at <http://www.w3.org/TR/REC\-DOM\-Level\-1>
.PP
The PerlSAX specification. It is currently in lib/PerlSAX.pod in the
libxml-perl distribution by Ken MacLeod. 
.PP
The original \s-1SAX\s0 specification (Simple \s-1API\s0 for \s-1XML\s0) can be found at 
<http://www.megginson.com/SAX> and <http://www.megginson.com/SAX/SAX2>
