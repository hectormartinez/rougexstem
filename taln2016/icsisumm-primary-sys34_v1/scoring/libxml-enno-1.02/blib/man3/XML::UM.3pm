.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::UM 3"
.TH XML::UM 3 "2000-01-31" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
XML::UM \- Convert UTF\-8 strings to any encoding supported by XML::Encoding
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use XML::UM;
.Ve
.PP
.Vb 3
\& # Set directory with .xml files that comes with XML::Encoding distribution
\& # Always include the trailing slash!
\& $XML::UM::ENCDIR = '/home1/enno/perlModules/XML-Encoding-1.01/maps/';
.Ve
.PP
.Vb 4
\& # Create the encoding routine
\& my $encode = XML::UM::get_encode (
\&        Encoding => 'ISO-8859-2',
\&        EncodeUnmapped => \e&XML::UM::encode_unmapped_dec);
.Ve
.PP
.Vb 2
\& # Convert a string from UTF-8 to the specified Encoding
\& my $encoded_str = $encode->($utf8_str);
.Ve
.PP
.Vb 2
\& # Remove circular references for garbage collection
\& XML::UM::dispose_encoding ('ISO-8859-2');
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides methods to convert \s-1UTF\-8\s0 strings to any \s-1XML\s0 encoding
that XML::Encoding supports. It creates mapping routines from the .xml
files that can be found in the maps/ directory in the XML::Encoding
distribution. Note that the XML::Encoding distribution does install the 
\&.enc files in your perl directory, but not the.xml files they were created
from. That's why you have to specify \f(CW$ENCDIR\fR as in the \s-1SYNOPSIS\s0.
.PP
This implementation uses the XML::Encoding class to parse the .xml
file and creates a hash that maps \s-1UTF\-8\s0 characters (each consisting of up
to 4 bytes) to their equivalent byte sequence in the specified encoding. 
Note that large mappings may consume a lot of memory! 
.PP
Future implementations may parse the .enc files directly, or
do the conversions entirely in \s-1XS\s0 (i.e. C code.)
.SH "get_encode (Encoding => STRING, EncodeUnmapped => SUB)"
.IX Header "get_encode (Encoding => STRING, EncodeUnmapped => SUB)"
The central entry point to this module is the \fIXML::UM::get_encode()\fR method. 
It forwards the call to the global \f(CW$XML::UM::FACTORY\fR, which is defined as
an instance of XML::UM::SlowMapperFactory by default. Override this variable
to plug in your own mapper factory.
.PP
The XML::UM::SlowMapperFactory creates an instance of XML::UM::SlowMapper
(and caches it for subsequent use) that reads in the .xml encoding file and
creates a hash that maps \s-1UTF\-8\s0 characters to encoded characters.
.PP
The \fIget_encode()\fR method of XML::UM::SlowMapper is called, finally, which
generates an anonimous subroutine that uses the hash to convert 
multi-character \s-1UTF\-8\s0 blocks to the proper encoding.
.SH "dispose_encoding ($encoding_name)"
.IX Header "dispose_encoding ($encoding_name)"
Call this to free the memory used by the SlowMapper for a specific encoding.
Note that in order to free the big conversion hash, the user should no longer
have references to the subroutines generated by \fIget_encode()\fR.
.PP
The parameters to the \fIget_encode()\fR method (defined as name/value pairs) are:
.IP "* Encoding" 4
.IX Item "Encoding"
The name of the desired encoding, e.g. '\s-1ISO\-8859\-2\s0'
.IP "* EncodeUnmapped (Default: \e&XML::UM::encode_unmapped_dec)" 4
.IX Item "EncodeUnmapped (Default: &XML::UM::encode_unmapped_dec)"
Defines how Unicode characters not found in the mapping file (of the 
specified encoding) are printed. 
By default, they are converted to decimal entity references, like '&#123;'
.Sp
Use \e&XML::UM::encode_unmapped_hex for hexadecimal constants, like '&#xAB;'
.SH "CAVEATS"
.IX Header "CAVEATS"
I'm not exactly sure about which Unicode characters in the range (0 .. 127) 
should be mapped to themselves. See comments in \s-1XML/UM\s0.pm near
\&\f(CW%DEFAULT_ASCII_MAPPINGS\fR.
.PP
The encodings that expat supports by default are currently not supported, 
(e.g. \s-1UTF\-16\s0, \s-1ISO\-8859\-1\s0),
because there are no .enc files available for these encodings.
This module needs some more work. If you have the time, please help!
.SH "AUTHOR"
.IX Header "AUTHOR"
Send bug reports, hints, tips, suggestions to Enno Derksen at
<\fIenno@att.com\fR>. 
