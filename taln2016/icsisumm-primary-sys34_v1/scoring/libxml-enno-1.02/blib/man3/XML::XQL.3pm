.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::XQL 3"
.TH XML::XQL 3 "2000-01-31" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
XML::XQL \- A perl module for querying XML tree structures with XQL
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use XML::XQL;
\& use XML::XQL::DOM;
.Ve
.PP
.Vb 2
\& $parser = new XML::DOM::Parser;
\& $doc = $parser->parsefile ("file.xml");
.Ve
.PP
.Vb 4
\& # Return all elements with tagName='title' under the root element 'book'
\& $query = new XML::XQL::Query (Expr => "book/title");
\& @result = $query->solve ($doc);
\& $query->dispose; # Avoid memory leaks - Remove circular references
.Ve
.PP
.Vb 2
\& # Or (to save some typing)
\& @result = XML::XQL::solve ("book/title", $doc);
.Ve
.PP
.Vb 2
\& # Or (to save even more typing)
\& @result = $doc->xql ("book/title");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \s-1XML::XQL\s0 module implements the \s-1XQL\s0 (\s-1XML\s0 Query Language) proposal
submitted to the \s-1XSL\s0 Working Group in September 1998.
The spec can be found at: <http://www.w3.org/TandS/QL/QL98/pp/xql.html>
Most of the contents related to the \s-1XQL\s0 syntax can also be found in the
XML::XQL::Tutorial that comes with this distribution. 
Note that \s-1XQL\s0 is not the same as \s-1XML\-QL\s0!
.PP
The current implementation only works with the \s-1XML::DOM\s0 module, but once the
design is stable and the major bugs are flushed out, other extensions might
follow, e.g. for XML::Grove.
.PP
\&\s-1XQL\s0 was designed to be extensible and this implementation tries to stick to that.
Users can add their own functions, methods, comparison operators and data types.
Plugging in a new \s-1XML\s0 tree structure (like XML::Grove) should be a piece of cake.
.PP
To use the \s-1XQL\s0 module, either
.PP
.Vb 1
\&  use XML::XQL;
.Ve
.PP
or
.PP
.Vb 1
\&  use XML::XQL::Strict;
.Ve
.PP
The Strict module only provides the core \s-1XQL\s0 functionality as found in the
\&\s-1XQL\s0 spec. By default (i.e. by using \s-1XML::XQL\s0) you get '\s-1XQL+\s0', which has
some additional features.
.PP
See the section \*(L"Additional Features in \s-1XQL+\s0\*(R" for the differences.
.PP
This module is still in development. See the To-do list in \s-1XQL\s0.pm for what
still needs to be done. Any suggestions are welcome, the sooner these 
implementation issues are resolved, the faster we can all use this module.
.PP
If you find a bug, you would do me great favor by sending it to me in the
form of a test case. See the file t/xql_template.t that comes with this distribution.
.PP
If you have written a cool comparison operator, function, method or \s-1XQL\s0 data 
type that you would like to share, send it to enno@att.com and I will
add it to this module.
.SH "XML::XQL global functions"
.IX Header "XML::XQL global functions"
.IP "solve (\s-1QUERY_STRING\s0, \s-1INPUT_LIST\s0...)" 4
.IX Item "solve (QUERY_STRING, INPUT_LIST...)"
.Vb 1
\& @result = XML::XQL::solve ("doc//book", $doc);
.Ve
.Sp
This is provided as a shortcut for:
.Sp
.Vb 3
\& $query = new XML::XQL::Query (Expr => "doc//book");
\& @result = $query->solve ($doc);
\& $query->dispose;
.Ve
.Sp
Note that with \s-1XML::XQL::DOM\s0, you can also write (see XML::DOM::Node
for details):
.Sp
.Vb 1
\& @result = $doc->xql ("doc//book");
.Ve
.IP "setDocParser (\s-1PARSER\s0)" 4
.IX Item "setDocParser (PARSER)"
Sets the XML::DOM::Parser that is used by the new \s-1XQL+\s0 \fIdocument()\fR method.
By default it uses an XML::DOM::Parser that was created without any arguments,
i.e.
.Sp
.Vb 1
\&  $PARSER = new XML::DOM::Parser;
.Ve
.IP "defineFunction (\s-1NAME\s0, \s-1FUNCREF\s0, \s-1ARGCOUNT\s0 [, \s-1ALLOWED_OUTSIDE\s0 [, \s-1CONST\s0, [\s-1QUERY_ARG\s0]]])" 4
.IX Item "defineFunction (NAME, FUNCREF, ARGCOUNT [, ALLOWED_OUTSIDE [, CONST, [QUERY_ARG]]])"
Defines the \s-1XQL\s0 function (at the global level, i.e. for all newly created 
queries) with the specified \s-1NAME\s0. The \s-1ARGCOUNT\s0 parameter can either be a single
number or a reference to a list with numbers. 
A single number expands to [\s-1ARGCOUNT\s0, \s-1ARGCOUNT\s0]. The list contains pairs of 
numbers, indicating the number of arguments that the function allows. The value
\&\-1 means infinity. E.g. [2, 5, 7, 9, 12, \-1] means that the function can have
2, 3, 4, 5, 7, 8, 9, 12 or more arguments.
The number of arguments is checked when parsing the \s-1XQL\s0 query string.
.Sp
The second parameter must be a reference to a Perl function or an anonymous
sub. E.g. '\e&my_func' or 'sub { ... code ... }'
.Sp
If \s-1ALLOWED_OUTSIDE\s0 (default is 0) is set to 1, the function or method may 
also be used outside subqueries in \fInode queries\fR.
(See NodeQuery parameter in Query constructor)
.Sp
If \s-1CONST\s0 (default is 0) is set to 1, the function is considered to be 
\&\*(L"constant\*(R". See \*(L"Constant Function Invocations\*(R" for details.
.Sp
If \s-1QUERY_ARG\s0 (default is 0) is not \-1, the argument with that index is
considered to be a 'query parameter'. If the query parameter is a subquery, 
that returns multiple values, the result list of the function invocation will
contain one result value for each value of the subquery. 
E.g. 'length(book/author)' will return a list of Numbers, denoting the string 
lengths of all the author elements returned by 'book/author'.
.Sp
Note that only methods (not functions) may appear after a Bang \*(L"!\*(R" operator.
This is checked when parsing the \s-1XQL\s0 query string.
.Sp
See also: defineMethod
.IP "generateFunction (\s-1NAME\s0, \s-1FUNCNAME\s0, \s-1RETURN_TYPE\s0 [, \s-1ARGCOUNT\s0 [, \s-1ALLOWED_OUTSIDE\s0 [, \s-1CONST\s0 [, \s-1QUERY_ARG\s0]]]])" 4
.IX Item "generateFunction (NAME, FUNCNAME, RETURN_TYPE [, ARGCOUNT [, ALLOWED_OUTSIDE [, CONST [, QUERY_ARG]]]])"
Generates and defines an \s-1XQL\s0 function wrapper for the Perl function with the
name \s-1FUNCNAME\s0. The function name will be \s-1NAME\s0 in \s-1XQL\s0 query expressions.
The return type should be one of the builtin \s-1XQL\s0 Data Types or a class derived
from XML::XQL::PrimitiveType (see \*(L"Adding Data Types\*(R".)
See defineFunction for the meaning of \s-1ARGCOUNT\s0, \s-1ALLOWED_OUTSIDE\s0, \s-1CONST\s0 and
\&\s-1QUERY_ARG\s0.
.Sp
Function values are always converted to Perl strings with xql_toString before
they are passed to the Perl function implementation. The function return value
is cast to an object of type \s-1RETURN_TYPE\s0, or to the empty list [] if the
result is undef. It uses expandType to expand \s-1XQL\s0 primitive type names.
If \s-1RETURN_TYPE\s0 is \*(L"*\*(R", it returns the function 
result as is, unless the function result is undef, in which case it returns [].
.IP "defineMethod (\s-1NAME\s0, \s-1FUNCREF\s0, \s-1ARGCOUNT\s0 [, \s-1ALLOWED_OUTSIDE\s0])" 4
.IX Item "defineMethod (NAME, FUNCREF, ARGCOUNT [, ALLOWED_OUTSIDE])"
Defines the \s-1XQL\s0 method (at the global level, i.e. for all newly created 
queries) with the specified \s-1NAME\s0. The \s-1ARGCOUNT\s0 parameter can either be a single
number or a reference to a list with numbers. 
A single number expands to [\s-1ARGCOUNT\s0, \s-1ARGCOUNT\s0]. The list contains pairs of 
numbers, indicating the number of arguments that the method allows. The value
\&\-1 means infinity. E.g. [2, 5, 7, 9, 12, \-1] means that the method can have
2, 3, 4, 5, 7, 8, 9, 12 or more arguments.
The number of arguments is checked when parsing the \s-1XQL\s0 query string.
.Sp
The second parameter must be a reference to a Perl function or an anonymous
sub. E.g. '\e&my_func' or 'sub { ... code ... }'
.Sp
If \s-1ALLOWED_OUTSIDE\s0 (default is 0) is set to 1, the function or method may 
also be used outside subqueries in \fInode queries\fR.
(See NodeQuery parameter in Query constructor)
.Sp
Note that only methods (not functions) may appear after a Bang \*(L"!\*(R" operator.
This is checked when parsing the \s-1XQL\s0 query string.
.Sp
See also: defineFunction
.IP "defineComparisonOperators (\s-1NAME\s0 => \s-1FUNCREF\s0 [, \s-1NAME\s0 => \s-1FUNCREF\s0]*)" 4
.IX Item "defineComparisonOperators (NAME => FUNCREF [, NAME => FUNCREF]*)"
Defines \s-1XQL\s0 comparison operators at the global level.
The \s-1FUNCREF\s0 parameters must be a references to a Perl function or an anonymous
sub. E.g. '\e&my_func' or 'sub { ... code ... }'
.Sp
E.g. define the operators \f(CW$my_op\fR$ and \f(CW$my_op2\fR$:
.Sp
.Vb 2
\& defineComparisonOperators ('my_op' => \e&my_op,
\&                            'my_op2' => sub { ... insert code here ... });
.Ve
.IP "defineElementValueConvertor (\s-1TAG_NAME\s0, \s-1FUNCREF\s0)" 4
.IX Item "defineElementValueConvertor (TAG_NAME, FUNCREF)"
Defines that the result of the \fIvalue()\fR call for Elements with the specified
\&\s-1TAG_NAME\s0 uses the specified function. The function will receive
two parameters. The second one is the \s-1TAG_NAME\s0 of the Element node 
and the first parameter is the Element node itself.
\&\s-1FUNCREF\s0 should be a reference to a Perl function, e.g. \e&my_sub, or
an anonymous sub.
.Sp
E.g. to define that all Elements with tag name 'date\-of\-birth' should return
XML::XQL::Date objects:
.Sp
.Vb 7
\&        defineElementValueConvertor ('date-of-birth', sub {
\&                my $elem = shift;
\&                # Always pass in the node as the second parameter. This is
\&                # the reference node for the object, which is used when
\&                # sorting values in document order.
\&                new XML::XQL::Date ($elem->xql_text, $elem); 
\&        });
.Ve
.Sp
These convertors can only be specified at a global level, not on a per query
basis. To undefine a convertor, simply pass a \s-1FUNCREF\s0 of undef.
.IP "defineAttrValueConvertor (\s-1ELEM_TAG_NAME\s0, \s-1ATTR_NAME\s0, \s-1FUNCREF\s0)" 4
.IX Item "defineAttrValueConvertor (ELEM_TAG_NAME, ATTR_NAME, FUNCREF)"
Defines that the result of the \fIvalue()\fR call for Attributes with the specified
\&\s-1ATTR_NAME\s0 and a parent Element with the specified \s-1ELEM_TAG_NAME\s0 
uses the specified function. An \s-1ELEM_TAG_NAME\s0 of \*(L"*\*(R" will match regardless of
the tag name of the parent Element. The function will receive
3 parameters. The third one is the tag name of the parent Element (even if 
\&\s-1ELEM_TAG_NAME\s0 was \*(L"*\*(R"), the second is the \s-1ATTR_NAME\s0 and the first is the 
Attribute node itself.
\&\s-1FUNCREF\s0 should be a reference to a Perl function, e.g. \e&my_sub, or
an anonymous sub.
.Sp
These convertors can only be specified at a global level, not on a per query
basis. To undefine a convertor, simply pass a \s-1FUNCREF\s0 of undef.
.IP "defineTokenQ (Q)" 4
.IX Item "defineTokenQ (Q)"
Defines the token for the q// string delimiters at a global level.
The default value for \s-1XQL+\s0 is 'q', for XML::XQL::Strict it is undef.
A value of undef will deactivate this feature.
.IP "defineTokenQQ (\s-1QQ\s0)" 4
.IX Item "defineTokenQQ (QQ)"
Defines the token for the qq// string delimiters at a global level.
The default value for \s-1XQL+\s0 is 'qq', for XML::XQL::Strict it is undef.
A value of undef will deactivate this feature.
.IP "expandType (\s-1TYPE\s0)" 4
.IX Item "expandType (TYPE)"
Used internally to expand type names of \s-1XQL\s0 primitive types.
E.g. it expands \*(L"Number\*(R" to \*(L"XML::XQL::Number\*(R" and is not case\-sensitive, so
\&\*(L"number\*(R" and \*(L"NuMbEr\*(R" will both expand correctly.
.IP "defineExpandedTypes (\s-1ALIAS\s0, \s-1FULL_NAME\s0 [, ...])" 4
.IX Item "defineExpandedTypes (ALIAS, FULL_NAME [, ...])"
For each pair of arguments it allows the class name \s-1FULL_NAME\s0 to be abbreviated
with \s-1ALIAS\s0. The definitions are used by \fIexpandType()\fR. 
(\s-1ALIAS\s0 is always converted to lowercase internally, because expandType 
is case\-insensitive.)
.Sp
Overriding the \s-1ALIAS\s0 for \*(L"date\*(R", also affects the object type returned by the
\&\fIdate()\fR function.
.IP "setErrorContextDelimiters (\s-1START\s0, \s-1END\s0, \s-1BOLD_ON\s0, \s-1BOLD_OFF\s0)" 4
.IX Item "setErrorContextDelimiters (START, END, BOLD_ON, BOLD_OFF)"
Sets the delimiters used when printing error messages during query evaluation.
The default delimiters on Unix are `tput smul` (underline on) and `tput rmal`
(underline off). On other systems (that don't have tput), the delimiters are
\&\*(L">>\*(R" and \*(L"<<\*(R" resp. 
.Sp
When printing the error message, the subexpression that caused the error will
be enclosed by the delimiters, i.e. underlined on Unix.
.Sp
For certain subexpressions the significant keyword, e.g. \*(L"$and$\*(R" is enclosed in 
the bold delimiters \s-1BOLD_ON\s0 (default: `tput bold` on Unix, "\*(L" elsewhere) and 
\&\s-1BOLD_OFF\s0 (default: (`tput rmul` . `tput smul`) on Unix, \*(R"" elsewhere, 
see \f(CW$BoldOff\fR in \s-1XML::XQL::XQL\s0.pm for details.)
.IP "isEmptyList (\s-1VAR\s0)" 4
.IX Item "isEmptyList (VAR)"
Returns 1 if \s-1VAR\s0 is [], else 0. Can be used in user defined functions.
.SH "Additional Features in XQL+"
.IX Header "Additional Features in XQL+"
.IP "Parent operator '..'" 4
.IX Item "Parent operator '..'"
The '..' operator returns the parent of the current node, where '.' would
return the current node. This is not part of any \s-1XQL\s0 standard, because you
would normally use return operators, which are not implemented here.
.IP "Sequence operators ';' and ';;'" 4
.IX Item "Sequence operators ';' and ';;'"
The sequence operators ';' (precedes) and ';;' (immediately precedes) are
not in the \s-1XQL\s0 spec, but are described in 'The Design of \s-1XQL\s0' by Jonathan Robie
who is one of the designers of \s-1XQL\s0. It can be found at
<http://www.texcel.no/whitepapers/xql\-design.html>
See also the \s-1XQL\s0 Tutorial for a description of what they mean.
.IP "q// and qq// String Tokens" 4
.IX Item "q// and qq// String Tokens"
String tokens a la q// and qq// are allowed. q// evaluates like Perl's single 
quotes and qq// like Perl's double quotes. Note that the default \s-1XQL\s0 strings do
not allow escaping etc., so it's not possible to define a string with both
single and double quotes. If 'q' and 'qq' are not to your liking, you may
redefine them to something else or undefine them altogether, by assigning undef
to them. E.g:
.Sp
.Vb 3
\& # at a global level - shared by all queries (that don't (re)define 'q')
\& XML::XQL::defineTokenQ ('k');
\& XML::XQL::defineTokenQQ (undef);
.Ve
.Sp
.Vb 2
\& # at a query level - only defined for this query
\& $query = new XML::XQL::Query (Expr => "book/title", q => 'k', qq => undef);
.Ve
.Sp
From now on k// works like q// did and qq// doesn't work at all anymore.
.IP "Query strings can have embedded Comments" 4
.IX Item "Query strings can have embedded Comments"
For example:
.Sp
.Vb 2
\& $queryExpr = "book/title          # this comment is inside the query string
\&               [. = 'Moby Dick']"; # this comment is outside
.Ve
.IP "Optional dollar delimiters and case-insensitive \s-1XQL\s0 keywords" 4
.IX Item "Optional dollar delimiters and case-insensitive XQL keywords"
The following \s-1XQL\s0 keywords are case-insensitive and the dollar sign delimiters 
may be omitted: \f(CW$and\fR$, \f(CW$or\fR$, \f(CW$not\fR$, \f(CW$union\fR$, \f(CW$intersect\fR$, \f(CW$to\fR$, \f(CW$any\fR$, \f(CW$all\fR$,
\&\f(CW$eq\fR$, \f(CW$ne\fR$, \f(CW$lt\fR$, \f(CW$gt\fR$, \f(CW$ge\fR$, \f(CW$le\fR$, \f(CW$ieq\fR$, \f(CW$ine\fR$, \f(CW$ilt\fR$, \f(CW$igt\fR$, \f(CW$ige\fR$, \f(CW$ile\fR$.
.Sp
E.g. \f(CW$AND\fR$, \f(CW$And\fR$, \f(CW$aNd\fR$, and, And, aNd are all valid replacements for \f(CW$and\fR$.
.Sp
Note that \s-1XQL+\s0 comparison operators ($match$, \f(CW$no_match\fR$, \f(CW$isa\fR$, \f(CW$can\fR$) still
require dollar delimiters and are case\-sensitive.
.ie n .IP "Comparison operator: $match$ or '=~'" 4
.el .IP "Comparison operator: \f(CW$match\fR$ or '=~'" 4
.IX Item "Comparison operator: $match$ or '=~'"
E.g. \*(L"book/title =~ '/(Moby|Dick)/']\*(R" will return all book titles containing
Moby or Dick. Note that the match expression needs to be quoted and should
contain the // or m// delimiters for Perl.
.Sp
When casting the values to be matched, both are converted to Text.
.ie n .IP "Comparison operator: $no_match$ or '!~'" 4
.el .IP "Comparison operator: \f(CW$no_match\fR$ or '!~'" 4
.IX Item "Comparison operator: $no_match$ or '!~'"
E.g. \*(L"book/title !~ '/(Moby|Dick)/']\*(R" will return all book titles that don't 
contain Moby or Dick. Note that the match expression needs to be quoted and 
should contain the // or m// delimiters for Perl.
.Sp
When casting the values to be matched, both are converted to Text.
.ie n .IP "Comparison operator: $isa$" 4
.el .IP "Comparison operator: \f(CW$isa\fR$" 4
.IX Item "Comparison operator: $isa$"
E.g. '//. \f(CW$isa\fR$ \*(L"XML::XQL::Date\*(R"' returns all elements for which the \fIvalue()\fR 
function returns an XML::XQL::Date object. (Note that the \fIvalue()\fR function can
be overridden to return a specific object type for certain elements and 
attributes.) It uses expandType to expand \s-1XQL\s0 primitive type names.
.ie n .IP "Comparison operator: $can$" 4
.el .IP "Comparison operator: \f(CW$can\fR$" 4
.IX Item "Comparison operator: $can$"
E.g. '//. \f(CW$can\fR$ \*(L"swim\*(R"' returns all elements for which the \fIvalue()\fR 
function returns an object that implements the (Perl) \fIswim()\fR method. 
(Note that the \fIvalue()\fR function can be overridden to return a specific object 
type for certain elements and attributes.)
.IP "Function: once (\s-1QUERY\s0)" 4
.IX Item "Function: once (QUERY)"
E.g. 'once(id(\*(L"foo\*(R"))' will evaluate the \s-1QUERY\s0 expression only once per query.
Certain query results (like the above example) will always return the same
value within a query. Using \fIonce()\fR will cache the \s-1QUERY\s0 result for the
rest of the query. 
.Sp
Note that \*(L"constant\*(R" function invocations are always cached.
See also \*(L"Constant Function Invocations\*(R"
.IP "Function: subst (\s-1QUERY\s0, \s-1EXPR\s0, \s-1EXPR\s0 [,MODIFIERS, [\s-1MODE\s0]])" 4
.IX Item "Function: subst (QUERY, EXPR, EXPR [,MODIFIERS, [MODE]])"
E.g. 'subst(book/title, \*(L"[M|m]oby\*(R", \*(L"Dick\*(R", \*(L"g\*(R")' will replace Moby or moby
with Dick globally (\*(L"g\*(R") in all book title elements. Underneath it uses Perl's
substitute operator s///. Don't worry about which delimiters are used underneath.
The function returns all the book/titles for which a substitution occurred.
The default \s-1MODIFIERS\s0 string is "\*(L" (empty.) The function name may be abbreviated 
to \*(R"s".
.Sp
For most Node types, it converts the \fIvalue()\fR to a string (with xql_toString)
to match the string and xql_setValue to set the new value in case it matched.
For \s-1XQL\s0 primitives (Boolean, Number, Text) and other data types (e.g. Date) it 
uses xql_toString to match the String and xql_setValue to set the result. 
Beware that performing a substitution on a primitive that was found in the 
original \s-1XQL\s0 query expression, changes the value of that constant.
.Sp
If \s-1MODE\s0 is 0 (default), it treats Element nodes differently by matching and
replacing \fItext blocks\fR occurring in the Element node. A text block is defined
as the concatenation of the raw text of subsequent Text, CDATASection and 
EntityReference nodes. In this mode it skips embedded Element nodes.
If a text block matches, it is replaced by a single Text node, regardless
of the original node type(s).
.Sp
If \s-1MODE\s0 is 1, it treats Element nodes like the other nodes, i.e. it converts
the \fIvalue()\fR to a string etc. Note that the default implementation of \fIvalue()\fR
calls \fItext()\fR, which normalizes whitespace and includes embedded Element
descendants (recursively.) This is probably not what you want to use in most
cases, but since I'm not a professional psychic... :\-)
.IP "Function: map (\s-1QUERY\s0, \s-1CODE\s0)" 4
.IX Item "Function: map (QUERY, CODE)"
E.g. 'map(book/title, \*(L"s/[M|m]oby/Dick/g; \f(CW$_\fR\*(R")' will replace Moby or moby
with Dick globally (\*(L"g\*(R") in all book title elements. Underneath it uses Perl's
map operator. The function returns all the book/titles for which a 
change occurred.
.Sp
??? add more specifics
.IP "Function: eval (\s-1EXPR\s0 [,TYPE])" 4
.IX Item "Function: eval (EXPR [,TYPE])"
Evaluates the Perl expression \s-1EXPR\s0 and returns an object of the specified \s-1TYPE\s0.
It uses expandType to expand \s-1XQL\s0 primitive type names.
If the result of the eval was undef, the empty list [] is returned.
.Sp
E.g. 'eval(\*(L"2 + 5\*(R", \*(L"Number\*(R")' returns a Number object with the value 7, and
     'eval(\*(L"%ENV{\s-1USER\s0}\*(R")' returns a Text object with the user name.
.Sp
Consider using \fIonce()\fR to cache the return value, when the invocation will 
return the same result for each invocation within a query.
.Sp
??? add more specifics
.IP "Function: new (\s-1TYPE\s0 [, \s-1QUERY\s0 [, \s-1PAR\s0] *])" 4
.IX Item "Function: new (TYPE [, QUERY [, PAR] *])"
Creates a new object of the specified object \s-1TYPE\s0. The constructor may have any
number of arguments. The first argument of the constructor (the 2nd argument 
of the \fInew()\fR function) is considered to be a 'query parameter'.
See defineFunction for a definition of \fIquery parameter\fR.
It uses expandType to expand \s-1XQL\s0 primitive type names.
.IP "Function: document (\s-1QUERY\s0) or doc (\s-1QUERY\s0)" 4
.IX Item "Function: document (QUERY) or doc (QUERY)"
The \fIdocument()\fR function creates a new XML::XML::Document for each result 
of \s-1QUERY\s0 (\s-1QUERY\s0 may be a simple string expression, like \*(L"/usr/enno/file.xml\*(R". 
See t/xql_document.t or below for an example with a more complex \s-1QUERY\s0.)
.Sp
\&\fIdocument()\fR may be abbreviated to \fIdoc()\fR.
.Sp
\&\fIdocument()\fR uses an XML::DOM::Parser underneath, which can be set with
\&\fIXML::XQL::setDocParser()\fR. By default it uses a parser that was created without
any arguments, i.e.
.Sp
.Vb 1
\&  $PARSER = new XML::DOM::Parser;
.Ve
.Sp
Let's try a more complex example, assuming \f(CW$doc\fR contains:
.Sp
.Vb 4
\& <doc>
\&  <file name="file1.xml"/>
\&  <file name="file2.xml"/>
\& </doc>
.Ve
.Sp
Then the following query will return two XML::XML::Documents, 
one for file1.xml and one for file2.xml:
.Sp
.Vb 1
\& @result = XML::XQL::solve ("document(doc/file/@name)", $doc);
.Ve
.Sp
The resulting documents can be used as input for following queries, e.g.
.Sp
.Vb 1
\& @result = XML::XQL::solve ("document(doc/file/@name)/root/bla", $doc);
.Ve
.Sp
will return all /root/bla elements from the documents returned by \fIdocument()\fR.
.IP "Method: DOM_nodeType ()" 4
.IX Item "Method: DOM_nodeType ()"
Returns the \s-1DOM\s0 node type. Note that these are mostly the same as \fInodeType()\fR,
except for CDATASection and EntityReference nodes. \fIDOM_nodeType()\fR returns
4 and 5 respectively, whereas \fInodeType()\fR returns 3, because they are 
considered text nodes.
.IP "Function wrappers for Perl builtin functions" 4
.IX Item "Function wrappers for Perl builtin functions"
\&\s-1XQL\s0 function wrappers have been provided for most Perl builtin functions.
When using a Perl builtin function like \*(L"substr\*(R" in an \s-1XQL+\s0 querry, an
\&\s-1XQL\s0 function wrapper will be generated on the fly. The arguments to these
functions may be regular \s-1XQL+\s0 subqueries (that return one or more values) for
a \fIquery parameter\fR (see generateFunction for a definition.)
Most wrappers of Perl builtin functions have argument 0 for a query parameter,
except for: chmod (parameter 1 is the query parameter), chown (2) and utime (2).
The following functions have no query parameter, which means that all parameters
should be a single value: atan2, rand, srand, sprintf, rename, unlink, system.
.Sp
The function result is casted to the appropriate \s-1XQL\s0 primitive type (Number, 
Text or Boolean), or to an empty list if the result was undef.
.Sh "XPath functions and methods"
.IX Subsection "XPath functions and methods"
The following functions were found in the XPath specification:
.IP "Function: concat (\s-1STRING\s0, \s-1STRING\s0, STRING*)" 4
.IX Item "Function: concat (STRING, STRING, STRING*)"
The concat function returns the concatenation of its arguments.
.IP "Function: starts-with (\s-1STRING\s0, \s-1STRING\s0)" 4
.IX Item "Function: starts-with (STRING, STRING)"
The starts-with function returns true if the first argument string starts with 
the second argument string, and otherwise returns false.
.IP "Function: contains (\s-1STRING\s0, \s-1STRING\s0)" 4
.IX Item "Function: contains (STRING, STRING)"
The contains function returns true if the first argument string contains the 
second argument string, and otherwise returns false.
.IP "Function: substring-before (\s-1STRING\s0, \s-1STRING\s0)" 4
.IX Item "Function: substring-before (STRING, STRING)"
The substring-before function returns the substring of the first argument 
string that precedes the first occurrence of the second argument string
in the first argument string, or the empty string if the first argument 
string does not contain the second argument string. For example,
.Sp
.Vb 1
\& substring-before("1999/04/01","/") returns 1999.
.Ve
.IP "Function: substring-after (\s-1STRING\s0, \s-1STRING\s0)" 4
.IX Item "Function: substring-after (STRING, STRING)"
The substring-after function returns the substring of the first argument string 
that follows the first occurrence of the second argument string in
the first argument string, or the empty string if the first argument string does
not contain the second argument string. For example,
.Sp
.Vb 1
\& substring-after("1999/04/01","/") returns 04/01,
.Ve
.Sp
and 
.Sp
.Vb 1
\& substring-after("1999/04/01","19") returns 99/04/01.
.Ve
.IP "Function: substring (\s-1STRING\s0, \s-1NUMBER\s0 [, \s-1NUMBER\s0] )" 4
.IX Item "Function: substring (STRING, NUMBER [, NUMBER] )"
The substring function returns the substring of the first argument starting at 
the position specified in the second argument with length specified in
the third argument. For example, 
.Sp
.Vb 1
\& substring("12345",2,3) returns "234".
.Ve
.Sp
If the third argument is not specified, it returns the substring 
starting at the position specified in the second argument and continuing to 
the end of the string. For example, 
.Sp
.Vb 1
\& substring("12345",2) returns "2345".
.Ve
.Sp
More precisely, each character in the string is considered 
to have a numeric position: the position of the first character is 1,
the position of the second character is 2 and so on.
.Sp
\&\s-1NOTE:\s0 This differs from the \fBsubstr\fR method , in which the
method treats the position of the first character as 0.
.Sp
The XPath spec says this about rounding, but that is not true in this 
implementation: 
\&\fIThe returned substring contains those characters for which the position of the 
character is greater than or equal to the rounded value of the
second argument and, if the third argument is specified, less than the 
sum of the rounded value of the second argument and the rounded value of
the third argument; the comparisons and addition used for the above 
follow the standard \s-1IEEE\s0 754 rules; rounding is done as if by a call to the
round function.\fR
.IP "Method: string-length ( [ \s-1QUERY\s0 ] )" 4
.IX Item "Method: string-length ( [ QUERY ] )"
The string-length returns the number of characters in the string. 
If the argument is omitted, it defaults to the context node
converted to a string, in other words the string-value of the context node.
.Sp
Note that the generated \s-1XQL\s0 wrapper for the Perl built-in \fBsubstr\fR does not
allow the argument to be omitted.
.IP "Method: normalize-space ( [ \s-1QUERY\s0 ] )" 4
.IX Item "Method: normalize-space ( [ QUERY ] )"
The normalize-space function returns the argument string with whitespace 
normalized by stripping leading and trailing whitespace and replacing
sequences of whitespace characters by a single space. Whitespace characters are 
the same as those allowed by the S production in \s-1XML\s0. If the
argument is omitted, it defaults to the context node converted to a string, in 
other words the string-value of the context node.
.IP "Function: translate (\s-1STRING\s0, \s-1STRING\s0, \s-1STRING\s0)" 4
.IX Item "Function: translate (STRING, STRING, STRING)"
The translate function returns the first argument string with occurrences of 
characters in the second argument string replaced by the character at
the corresponding position in the third argument string. For example, 
.Sp
.Vb 1
\& translate("bar","abc","ABC") returns the string BAr.
.Ve
.Sp
If there is a
character in the second argument string with no character at a corresponding
position in the third argument string (because the second argument
string is longer than the third argument string), then occurrences of that 
character in the first argument string are removed. For example,
.Sp
.Vb 1
\& translate("--aaa--","abc-","ABC") returns "AAA".
.Ve
.Sp
If a character occurs more than once in the second argument string, then the 
first occurrence determines the replacement character. If the third argument 
string is longer than the second argument string, then excess characters
are ignored.
.Sp
\&\s-1NOTE:\s0 The translate function is not a sufficient solution for case conversion 
in all languages. A future version may
provide additional functions for case conversion.
.Sp
This function was implemented using tr///d.
.IP "Function: sum ( \s-1QUERY\s0 )" 4
.IX Item "Function: sum ( QUERY )"
The sum function returns the sum of the \s-1QUERY\s0 results, by
converting the string values of each result to a number.
.IP "Function: floor (\s-1NUMBER\s0)" 4
.IX Item "Function: floor (NUMBER)"
The floor function returns the largest (closest to positive infinity) number 
that is not greater than the argument and that is an integer.
.IP "Function: ceiling (\s-1NUMBER\s0)" 4
.IX Item "Function: ceiling (NUMBER)"
The ceiling function returns the smallest (closest to negative infinity) number 
that is not less than the argument and that is an integer.
.IP "Function: round (\s-1NUMBER\s0)" 4
.IX Item "Function: round (NUMBER)"
The round function returns the number that is closest to the argument 
and that is an integer. If there are two such numbers, then the one that is
closest to positive infinity is returned.
.SH "Implementation Details"
.IX Header "Implementation Details"
.IP "\s-1XQL\s0 Builtin Data Types" 4
.IX Item "XQL Builtin Data Types"
The \s-1XQL\s0 engine uses the following object classes internally. Only Number, 
Boolean and Text are considered \fIprimitive \s-1XQL\s0 types\fR:
.RS 4
.IP "* XML::XQL::Number" 4
.IX Item "XML::XQL::Number"
For integers and floating point numbers.
.IP "* XML::XQL::Boolean" 4
.IX Item "XML::XQL::Boolean"
For booleans, e.g returned by \fItrue()\fR and \fIfalse()\fR.
.IP "* XML::XQL::Text" 4
.IX Item "XML::XQL::Text"
For string values.
.IP "* XML::XQL::Date" 4
.IX Item "XML::XQL::Date"
For date, time and date/time values. E.g. returned by the \fIdate()\fR function.
.IP "* XML::XQL::Node" 4
.IX Item "XML::XQL::Node"
Superclass of all \s-1XML\s0 node types. E.g. all subclasses of XML::DOM::Node subclass
from this.
.IP "* Perl list reference" 4
.IX Item "Perl list reference"
Lists of values are passed by reference (i.e. using [] delimiters).
The empty list [] has a double meaning. It also means 'undef' in certain 
situations, e.g. when a function invocation or comparison failed.
.RE
.RS 4
.RE
.IP "Type casting in comparisons" 4
.IX Item "Type casting in comparisons"
When two values are compared in an \s-1XML\s0 comparison (e.g. \f(CW$eq\fR$) the values are
first casted to the same data type. Node values are first replaced by their
\&\fIvalue()\fR (i.e. the \s-1XQL\s0 \fIvalue()\fR function is used, which returns a Text value by 
default, but may return any data type if the user so chooses.)
The resulting values are then casted to the type of the object with the highest
\&\fIxql_primType()\fR value. They are as follows: Node (0), Text (1), Number (2),
Boolean (3), Date (4), other data types (4 by default, but this may be
overriden by the user.)
.Sp
E.g. if one value is a Text value and the other is a Number, the Text value is 
cast to a Number and the resulting low-level (Perl) comparison is (for \f(CW$eq\fR$):
.Sp
.Vb 1
\& $number->xql_toString == $text->xql_toString
.Ve
.Sp
If both were Text values, it would have been
.Sp
.Vb 1
\& $text1->xql_toString eq $text2->xql_toString
.Ve
.Sp
Note that the \s-1XQL\s0 spec is vague and even conflicting where it concerns type
casting. This implementation resulted after talking to Joe Lapp, one of the
spec writers.
.IP "Adding Data Types" 4
.IX Item "Adding Data Types"
If you want to add your own data type, make sure it derives from 
XML::XQL::PrimitiveType and implements the necessary methods.
.Sp
I will add more stuff here to explain it all, but for now, look at the code
for the primitive \s-1XQL\s0 types or the Date class (XML::XQL::Date in Date.pm.)
.IP "Document Order" 4
.IX Item "Document Order"
The \s-1XQL\s0 spec states that query results always return their values in 
\&\fIdocument order\fR, which means the order in which they appeared in the original
\&\s-1XML\s0 document. Values extracted from Nodes (e.g. with \fIvalue()\fR, \fItext()\fR, \fIrawText()\fR,
\&\fInodeName()\fR, etc.) always have a pointer to the reference node (i.e. the Node
from which the value was extracted.) These pointers are acknowledged when
(intermediate) result lists are sorted. Currently, the only place where a
result list is sorted is in a \f(CW$union\fR$ expression, which is the only place
where the result list can be unordered.
(If you find that this is not true, let me know.)
.Sp
Non-node values that have no associated reference node, always end up at the end
of the result list in the order that they were added.
The \s-1XQL\s0 spec states that the reference node for an \s-1XML\s0 Attribute is the Element
to which it belongs, and that the order of values with the same reference node
is undefined. This means that the order of an Element and its attributes would 
be undefined.
But since the \s-1XML::DOM\s0 module keeps track of the order of the attributes, the
\&\s-1XQL\s0 engine does the same, and therefore, the attributes of an Element are
sorted and appear after their parent Element in a sorted result list.
.IP "Constant Function Invocations" 4
.IX Item "Constant Function Invocations"
If a function always returns the same value when given \*(L"constant\*(R" arguments,
the function is considered to be \*(L"constant\*(R". A \*(L"constant\*(R" argument can be
either an \s-1XQL\s0 primitive (Number, Boolean, Text) or a \*(L"constant\*(R" function
invocation. E.g. 
.Sp
.Vb 5
\& date("12-03-1998")
\& true()
\& sin(0.3)
\& length("abc")
\& date(substr("12-03-1998 is the date", 0, 10))
.Ve
.Sp
are constant, but not:
.Sp
.Vb 1
\& length(book[2])
.Ve
.Sp
Results of constant function invocations are cached and calculated only once
for each query. See also the \s-1CONST\s0 parameter in defineFunction.
It is not necessary to wrap constant function invocations in a \fIonce()\fR call.
.Sp
Constant \s-1XQL\s0 functions are: date, true, false and a lot of the \s-1XQL+\s0
wrappers for Perl builtin functions. Function wrappers for certain builtins
are not made constant on purpose to force the invocation to be evaluated
every time, e.g. 'mkdir(\*(L"/user/enno/my_dir\*(R", \*(L"0644\*(R")' (although constant
in appearance) may return different results for multiple invocations. 
See \f(CW%PerlFunc\fR in Plus.pm for details.
.IP "Function: count ([\s-1QUERY\s0])" 4
.IX Item "Function: count ([QUERY])"
The \fIcount()\fR function has no parameters in the \s-1XQL\s0 spec. In this implementation
it will return the number of \s-1QUERY\s0 results when passed a \s-1QUERY\s0 parameter.
.IP "Method: text ([\s-1RECURSE\s0])" 4
.IX Item "Method: text ([RECURSE])"
When expanding an Element node, the \fItext()\fR method adds the expanded \fItext()\fR value
of sub\-Elements. When \s-1RECURSE\s0 is set to 0 (default is 1), it will not include
sub\-elements. This is useful e.g. when using the \f(CW$match\fR$ operator in a recursive
context (using the // operator), so it won't return parent Elements when one of
the children matches.
.IP "Method: rawText ([\s-1RECURSE\s0])" 4
.IX Item "Method: rawText ([RECURSE])"
See \fItext()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
XML::XQL::Query, \s-1XML::XQL::DOM\s0, XML::XQL::Date
.PP
The Japanese version of this document can be found on-line at
<http://member.nifty.ne.jp/hippo2000/perltips/xml/xql.htm>
.PP
The XML::XQL::Tutorial manual page. The Japanese version can be found at 
<http://member.nifty.ne.jp/hippo2000/perltips/xml/xql/tutorial.htm>
.PP
The \s-1XQL\s0 spec at <http://www.w3.org/TandS/QL/QL98/pp/xql.html>
.PP
The Design of \s-1XQL\s0 at <http://www.texcel.no/whitepapers/xql\-design.html>
.PP
The \s-1DOM\s0 Level 1 specification at <http://www.w3.org/TR/REC\-DOM\-Level\-1>
.PP
The \s-1XML\s0 spec (Extensible Markup Language 1.0) at <http://www.w3.org/TR/REC\-xml>
.PP
The XML::Parser and XML::Parser::Expat manual pages.
.SH "AUTHOR"
.IX Header "AUTHOR"
Please send bugs, comments and suggestions to Enno Derksen <\fIenno@att.com\fR>
